#summary Protocol-Buffer Service C Mapping

= Introduction =

Protocol-Buffers defines a mapping for a Service, which boils down to list of methods, each having:
  * a name
  * an input message type
  * an output message type

The C binding protobuf-c defines a C structure, ProtobufCService, which is the basis for both
  * services generated by protoc-c (the protobuf C code generator)
  * services implemented by RPC systems (protobuf-c-rpc is an example)

When using the code generator, the service is "derived" from ProtobufCService like this (this is from the output of `protoc-c`):
 
{{{ 
 typedef struct _Foo__DirLookup_Service Foo__DirLookup_Service;
 struct _Foo__DirLookup_Service
 {
  ProtobufCService base;
  void (*by_name)(Foo__DirLookup_Service *service,
                  const Foo__Name *input,
                  Foo__LookupResult_Closure closure,
                  void *closure_data);
 };
}}}
We generate two macros:
   * `FOO__DIR_LOOKUP__BASE_INIT` which defines merely the functions for `base`.  It looks like:
{{{
#define FOO__DIR_LOOKUP__BASE_INIT \
    { &foo__dir_lookup__descriptor, protobuf_c_service_invoke_internal, NULL }
}}}
   * `FOO__DIR_LOOKUP__INIT(function_prefix__)` which assumes that all the methods required by this service are `function_prefix__` followed by the method name.  It looks like:
{{{
#define FOO__DIR_LOOKUP__INIT(function_prefix__) \
    { FOO__DIR_LOOKUP__BASE_INIT,\
      function_prefix__ ## by_name  }
}}}

We also generate a function for each method:
{{{
 void foo__dir_lookup__by_name(ProtobufCService *service,
                               const Foo__Name *input,
                               Foo__LookupResult_Closure closure,
                               void *closure_data)
 {
   PROTOBUF_C_ASSERT (service->descriptor == &foo__dir_lookup__descriptor);
   service->invoke(service, 0, (const ProtobufCMessage *) input, (ProtobufCClosure) closure, closure_data);
 }
}}}
Note that `foo__dir_lookup__by_name()` takes a `ProtobufCService`, not a 
`Foo__DirLookup_Service`:  that's because `foo__dir_lookup__by_name` also works on `ProtobufCService`s that are defined by an RPC system.  That's why it is NOT implemented:
{{{
  Foo__DirLookup_Service *s = (Foo__DirLookup_Service *) service;
  s->by_name (s, input, closure, closure_data);
}}}
That would not work for a service implemented by an RPC system.

= RPC Implementations =
RPC Implementation take advantage of the fact that all methods are marshalled through the `invoke` method of `ProtobufCService`:
{{{
struct _ProtobufCService
{
  const ProtobufCServiceDescriptor *descriptor;
  void (*invoke)(ProtobufCService *service,
                 unsigned          method_index,
                 const ProtobufCMessage *input,
                 ProtobufCClosure  closure,
                 void             *closure_data);
  void (*destroy) (ProtobufCService *service);
};
}}}
The generated code's invoke function is always the same:  invoke the function at `method_index`, assuming the list of methods directly follows the `ProtobufCService`.  This function is implemented in `protobuf-c.c`:
{{{
void
protobuf_c_service_invoke_internal(ProtobufCService *service,
                                  unsigned          method_index,
                                  const ProtobufCMessage *input,
                                  ProtobufCClosure  closure,
                                  void             *closure_data)
{
  GenericHandler *handlers;
  GenericHandler handler;

  /* Verify that method_index is within range.
     If this fails, you are likely invoking a newly added
     method on an old service.  (Although other memory corruption
     bugs can cause this assertion too) */
  PROTOBUF_C_ASSERT (method_index < service->descriptor->n_methods);

  /* Get the array of virtual methods (which are enumerated by 
     the generated code) */
  handlers = (GenericHandler *) (service + 1);

  /* get our method and invoke it */
  /* TODO: seems like handler==NULL is a situation that
     needs handling */
  handler = handlers[method_index];
  (*handler) (service, input, closure, closure_data);
}
}}}
(look at how that will do the right thing with `Foo__DirLookup_Service` above)

= Destruction =
The macros assume you don't need a destructor for this service.  That may be naive... so you must set the `destroy` function of `ProtobufCService`  before supplying the `ProtobufCService` to naive code that expects `destroy` to be adequate (or NULL to do nothing).

= Example Service Implementation =

We describe the example in `example-server.c` and `example-client.c` whose type (given in file `test.proto`) looks like:
{{{
package foo;

message LookupResult
{
  optional Person person = 1;
}

message Name {
  optional string name = 1;
};

service DirLookup {
  rpc ByName (Name) returns (LookupResult);
}
}}}



{{{
     typedef struct
     {
       // Foo_DirLookup must be the
       // first member of structure for casting below to work.
       Foo_DirLookup base;

       // any additional data required by the service follows.
       MYSQL *db;
     } Foo_DirLookup_Mysql;

     ProtobufCService *make_foo_dir_lookup_from_mysql (MYSQL *db_handle)
     {
       Foo_DirLookup_Mysql tmp
            = { FOO__DIR_LOOKUP__INIT(mysql__),
                b_handle };
       Foo_DirLookup_Mysql *rv = malloc (sizeof (Foo_DirLookup_Mysql));
       *rv = tmp;
       rv->base->base.destroy = mysql_service__destroy;
       return &rv->base.base;
     }
     static void 
     mysql__by_name (Foo__DirLookup_Service *service,
                     const Foo__Name        *input,
                     Foo__LookupResult_Closure closure,
                     void                   *closure_data)
     {
      Foo_DirLookup_Mysql *s = (Foo_DirLookup_Mysql *) service;
       /* omitted for clarity  --
           would use mysql calls to fill the response
           and invoke the closure */
       ...
     }
     static void mysql_service__destroy (ProtobufCService *service)
     {
       Foo_DirLookup_Mysql *s = (Foo_DirLookup_Mysql *) service;
       mysql_close (s->db);
       free (s);
     }
}}}